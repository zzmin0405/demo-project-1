# 구조

---
**개선사항 및 보완점 (풀스택 개발자 관점)**

현재 프로젝트는 `pnpm` 워크스페이스를 활용한 모노레포 구조로 `api` (NestJS)와 `web` (Next.js) 애플리케이션이 잘 분리되어 있습니다. 이는 확장성과 관리 용이성 측면에서 좋은 시작점입니다. 다음은 프로젝트의 견고함과 개발 효율성을 더욱 높이기 위한 개선 및 보완 사항입니다.

### 1. 모노레포 공통 패키지 활용 극대화

현재 `api`와 `web` 간에 공유될 수 있는 코드(예: 타입 정의, 유틸리티 함수, UI 컴포넌트)가 개별 앱 내에 중복되거나 비효율적으로 관리될 가능성이 있습니다.

*   **`packages/shared-types` 또는 `packages/common` 생성:**
    *   `api`와 `web` 애플리케이션 간에 공유되는 TypeScript 타입 정의 (인터페이스, DTOs), Enum, 상수 등을 이 패키지에 모아 관리합니다.
    *   이를 통해 타입 불일치로 인한 런타임 오류를 방지하고, 코드의 일관성을 유지할 수 있습니다. 특히 API 요청/응답 스키마나 WebSocket 이벤트 페이로드 등에 유용합니다.
*   **`packages/config` (선택 사항):**
    *   공통 `tsconfig.json`, `eslint.config.mjs`, `prettierrc` 등을 정의하여 모든 워크스페이스 패키지에 일관된 개발 환경을 제공합니다.

### 2. 백엔드 (NestJS - `ai-meet/apps/api`) 개선 사항

NestJS는 강력한 프레임워크이므로, 그 기능을 최대한 활용하여 견고한 API를 구축할 수 있습니다.

*   **환경 변수 관리:**
    *   `@nestjs/config` 모듈을 사용하여 `.env` 파일을 체계적으로 관리하고, 환경 변수에 대한 유효성 검사를 추가합니다. `process.env`를 직접 사용하는 것보다 안전하고 관리하기 용이합니다.
*   **데이터베이스 통합:**
    *   현재 데이터베이스 관련 모듈이 보이지 않습니다. TypeORM, Prisma, Mongoose 등 ORM/ODM을 선택하여 데이터베이스 연결 및 스키마를 정의하고, 관련 모듈(예: `DatabaseModule`, `UserModule`, `MeetingModule`)을 구성합니다.
    *   마이그레이션 도구를 사용하여 데이터베이스 스키마 변경 이력을 관리하고 배포 시 자동 적용되도록 합니다.
*   **입력 유효성 검사 (Validation):**
    *   `class-validator`와 `class-transformer`를 DTO(Data Transfer Object)에 적용하여 API 요청 데이터에 대한 강력한 유효성 검사를 구현합니다. 전역 `ValidationPipe`를 설정하여 모든 요청에 자동으로 적용되도록 합니다.
*   **구조화된 로깅:**
    *   `console.log` 대신 Winston, Pino 등 전문 로깅 라이브러리를 사용하여 구조화된 로깅을 구현합니다. 이는 운영 환경에서 로그 분석 및 문제 해결에 필수적입니다.
    *   로그 레벨(debug, info, warn, error)을 구분하여 관리합니다.
*   **API 문서화:**
    *   `@nestjs/swagger` 모듈을 사용하여 OpenAPI (Swagger) 문서를 자동으로 생성합니다. 이는 프론트엔드 개발자 및 다른 팀원들과의 API 명세 공유에 매우 유용합니다.
*   **헬스 체크 엔드포인트:**
    *   `/health`와 같은 헬스 체크 엔드포인트를 구현하여 서비스의 상태를 모니터링 시스템에 노출합니다.

### 3. 프론트엔드 (Next.js - `ai-meet/apps/web`) 개선 사항

Next.js의 App Router와 React의 기능을 활용하여 사용자 경험과 개발 효율성을 높일 수 있습니다.

*   **상태 관리 전략:**
    *   복잡한 미팅 애플리케이션의 경우, `useState`와 `useContext`만으로는 전역 상태 관리가 어려울 수 있습니다. Zustand, Jotai, Recoil 또는 Redux Toolkit과 같은 전역 상태 관리 라이브러리를 도입하여 애플리케이션의 복잡한 상태를 효율적으로 관리합니다.
*   **데이터 페칭 및 캐싱:**
    *   `react-query` (TanStack Query) 또는 `SWR`과 같은 데이터 페칭 라이브러리를 사용하여 백엔드 API와의 통신을 추상화하고, 캐싱, 재시도, 백그라운드 업데이트 등의 기능을 활용하여 사용자 경험을 개선하고 개발 복잡성을 줄입니다.
*   **컴포넌트 구조화:**
    *   `components/` 디렉토리 내에서 `components/ui/` 외에 기능별 또는 도메인별로 컴포넌트를 더 세분화하여 관리합니다 (예: `components/meeting/`, `components/auth/`, `components/layout/`). 이는 코드의 응집도를 높이고 재사용성을 향상시킵니다.
*   **환경 변수 관리:**
    *   Next.js의 환경 변수 규칙(`NEXT_PUBLIC_` 접두사)을 명확히 이해하고 적용하여 클라이언트/서버 환경 변수를 올바르게 분리합니다.

### 4. 공통 인프라 및 개발 프로세스 개선

*   **CI/CD 파이프라인 구축:**
    *   GitHub Actions, GitLab CI, Jenkins 등 CI/CD 도구를 사용하여 코드 푸시 시 자동으로 테스트 실행, 린팅, 빌드, 배포를 자동화합니다. 이는 코드 품질을 유지하고 배포 프로세스의 안정성을 확보하는 데 필수적입니다.
*   **컨테이너화 (Docker):**
    *   `api` 및 `web` 애플리케이션 각각에 대한 `Dockerfile`을 작성하여 컨테이너화합니다.
    *   루트 디렉토리에 `docker-compose.yml` 파일을 구성하여 로컬 개발 환경에서 데이터베이스, 백엔드, 프론트엔드를 한 번에 쉽게 실행할 수 있도록 합니다. 이는 개발 환경 설정의 일관성을 보장합니다.
*   **테스팅 전략 강화:**
    *   **단위 테스트:** 서비스 로직, 유틸리티 함수 등 개별 단위에 대한 테스트 커버리지를 높입니다.
    *   **통합 테스트:** API 엔드포인트, 데이터베이스 연동 등 여러 컴포넌트 간의 상호작용을 검증하는 통합 테스트를 작성합니다.
    *   **E2E 테스트:** Playwright 또는 Cypress와 같은 도구를 사용하여 사용자 시나리오 기반의 엔드투엔드 테스트를 구현하여 핵심 사용자 흐름의 안정성을 확보합니다.
*   **코드 품질 도구:**
    *   ESLint, Prettier 설정을 모든 프로젝트에 일관되게 적용하고, Git Hooks (예: Husky)를 사용하여 커밋 전에 자동으로 린팅 및 포맷팅을 실행하도록 합니다.
    *   TypeScript의 엄격한 모드를 활성화하고, 가능한 한 많은 타입 정보를 명시하여 코드의 안정성을 높입니다.

이러한 개선 사항들을 적용하면 프로젝트의 유지보수성, 확장성, 안정성이 크게 향상될 것입니다.
---