# 통신 모듈 안정성 및 동기/비동기 처리 분석

이 문서는 `events.gateway.ts` (서버)와 `meeting-client.tsx` (클라이언트)의 코드 레벨에서 동기/비동기 처리가 적절하게 구현되었는지, 그리고 안정성을 저해하는 요소가 있는지 분석한 결과입니다.

## 1. 서버 측 분석 (`events.gateway.ts`)

### `handleMediaChunk` (미디어 중계)
- **구현**: `async` 키워드가 없는 **동기 함수**로 구현되어 있습니다.
- **로직**:
  ```typescript
  client.to(roomId).emit('media-chunk', { ... });
  ```
- **분석**:
  - **매우 적절함**: 미디어 데이터는 대용량이고 빈번하게 발생하므로, 불필요한 `await` (DB 조회 등) 없이 즉시 브로드캐스트하는 것이 성능상 최선입니다.
  - Node.js의 이벤트 루프를 차단하지 않고 비동기 I/O(`socket.emit`)를 통해 전송하므로 병목 현상이 최소화되어 있습니다.

### `handleChatMessage` (채팅 처리)
- **구현**: `async/await`를 사용하는 **비동기 함수**입니다.
- **로직**: DB 저장(`prisma.chatLog.create`)을 기다리지만, `catch` 블록으로 에러를 처리하여 서버가 멈추지 않게 방어되어 있습니다.
- **분석**: 채팅은 미디어보다 빈도가 낮고 데이터 무결성이 중요하므로 적절한 구현입니다.

## 2. 클라이언트 측 분석 (`meeting-client.tsx`)

### `socket.on('media-chunk')` (수신부)
- **구현**: `async` 함수로 구현되어 있습니다.
- **로직**:
  1. `await blob.arrayBuffer()`: 바이너리 변환을 비동기로 처리하여 UI 스레드 차단을 방지합니다.
  2. `sourceBuffer.updating` 체크: **동기적**으로 플래그를 확인하여 `InvalidStateError`를 방지합니다.
  3. 큐(`chunkQueueRef`) 사용: 버퍼가 바쁠 경우 데이터를 메모리에 임시 저장하는 로직이 잘 구현되어 있습니다.

### `sourceBuffer.addEventListener('updateend')` (재생부)
- **구현**: `async` 이벤트 리스너입니다.
- **로직**:
  - `updateend` 이벤트는 앞선 버퍼 작업이 끝났을 때 발생하므로, 이 시점에 큐에 쌓인 다음 데이터를 처리하는 것은 **가장 안정적인 패턴**입니다.
  - `try-catch` 블록을 통해 `QuotaExceededError` (메모리 부족) 발생 시 오래된 버퍼를 비우는(`remove`) 로직이 포함되어 있습니다.

## 3. 안정성 평가 및 제언

### ✅ 잘된 점
1. **Non-blocking Server**: 서버가 미디어 패킷을 처리할 때 DB 등 느린 작업을 기다리지 않습니다.
2. **Event-driven Client**: 클라이언트가 `updateend` 이벤트를 기반으로 큐를 소비하므로, 타이머(`setInterval`) 방식보다 훨씬 안정적이고 효율적입니다.

### ⚠️ 불안정 요소 (코드 로직 외적인 부분)
1. **TCP Head-of-Line Blocking**:
   - 코드는 완벽하게 비동기로 작성되었으나, **WebSocket(TCP)** 프로토콜 자체의 특성상 패킷 하나가 유실되면 그 뒤의 모든 패킷이 대기 상태가 됩니다. 이는 코드 수정으로 해결할 수 없는 프로토콜의 한계입니다.
2. **청크 유실 정책**:
   - 클라이언트 코드에서 에러 발생 시(`QuotaExceededError` 등) 해당 청크를 `shift()` 하여 **버리는 정책**을 취하고 있습니다. 이는 멈춤(Stalling)을 막기 위한 고육지책이나, 화면이 순간적으로 깨지는 원인이 됩니다.

## 4. 결론
코드 레벨에서의 **동기/비동기 분리는 매우 잘 되어 있습니다.**
- 서버는 Non-blocking I/O를 준수합니다.
- 클라이언트는 Promise와 Event Loop를 적절히 활용하여 UI 멈춤 없이 미디어를 처리합니다.

현재의 "끊김" 현상은 코드의 논리적 오류보다는 **TCP 프로토콜의 물리적 특성**과 **공격적인 버퍼 설정(100ms)**에서 기인하는 것으로 판단됩니다.
